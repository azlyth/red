<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Testing</title>
    <script src="https://code.jquery.com/jquery-2.1.3.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/webcam.min.js" type="text/javascript" charset="utf-8"></script>
  </head>
  <style type="text/css" media="screen">
    html, body { height: 100%; width: 100%; }
    #webcam { width: 320px; height: 240px; visibility: visible; }
  </style>
  <body>
    <div id="webcam"></div>
  </body>
  <script type="text/javascript" charset="utf-8">
    var objects = [{
      url:                    'images/some.gif',
      step:                   0.02,                                     // in radians
      height:                 150,                                      // in pixels
      center:                 {left: 50, top: 50},                      // percent values
      radius:                 250,                                      // in pixels
      wobble:                 {distance: 10, radians: 0, step: 0.15},
      baseRate:               0.5,
      clockwise:              true,
      enableWobble:           true,
      timeInterval:           20,                                       // in milliseconds
      rateMultiplier:         12,
      initialRandomPosition:  true,
    }, {
      url:              'images/ian.jpg',
      step:             0.1,
      height:           100,
      center:           {left: 70, top: 20},
      radius:           100,
      baseRate:         0.5,
      clockwise:        false,
      timeInterval:     100,
      rateMultiplier:   10,
    }];


    // To be played with
    var all_default_to_random_position_on_circle = false;

    // Not to be played with
    var totalRed = 0;       // value between 0 and 1, constantly updated
    var TAU = Math.PI * 2;  // math stuff

    function rotateImage(obj, radians) {
      if (radians > TAU) radians -= TAU;

      // Calculate the position on the circle
      // NOTE: Code repeated in order to use less cycles
      if (obj.enableWobble) {
        obj.wobble.radians += obj.wobble.step;
        var radius = (obj.wobble.distance * Math.sin(obj.wobble.radians)) + obj.radius;
        var x_off = radius * Math.sin(radians);
        var y_off = radius * Math.cos(radians);
      } else {
        var x_off = obj.radius * Math.sin(radians);
        var y_off = obj.radius * Math.cos(radians);
      }

      // Apply the offset
      obj.img.offset({
        top: obj.center.top + y_off,
        left: obj.center.left + x_off,
      });

      // Queue up the next rotation
      setTimeout(function() {
        var adjustedStep = obj.step * (obj.baseRate + obj.rateMultiplier * totalRed);

        if (!obj.clockwise) {
          adjustedStep *= -1;
        }

        rotateImage(obj, radians - adjustedStep);
      }, obj.timeInterval);
    }

    function createImages() {
      for (var i = 0; i < objects.length; i++) {
        // Create the image
        var obj = objects[i]
        obj.img = document.createElement('img');
        obj.img.src = obj.url;
        obj.img.height = obj.height;
        updateCenter(obj);

        // Add it to the body
        document.body.appendChild(obj.img);
        obj.img = $(obj.img);

        // Configure the wobble
        if (!Boolean(obj.wobble)) {
          obj.wobble = {
            distance: 10,
            radians: 0,
            step: 0.15,
          };
        } else {
          if (!obj.wobble.distance) {
            obj.wobble.distance = 10;
          }
          if (!obj.wobble.radians) {
            obj.wobble.radians = 0;
          }
          if (!obj.wobble.step) {
            obj.wobble.step = 0.23;
          }
        }

        if (obj.initialRandomPosition === undefined) {
          obj.initialRandomPosition = all_default_to_random_position_on_circle;
        }

        // Dat closure, doe
        obj.img.load((function() {
          var _obj = obj;

          return function() {
            _obj.center.left -= _obj.img.width() / 2;
            _obj.center.top -= _obj.img.height() / 2;

            _obj.img.css('position', 'absolute');
            _obj.img.css('left', _obj.center.left);
            _obj.img.css('top', _obj.center.top);

            var radians = 0;
            if (_obj.initialRandomPosition) {
              radians = Math.random() * TAU;
            }

            rotateImage(_obj, radians);
          }
        })());
      }
    }

    function updateCenter(obj) {
        var _window = $(window);
        obj.center.left = _window.width() * obj.center.left / 100;
        obj.center.top = _window.height() * obj.center.top / 100;
    }

    function keepSummingThoseReds() {
      Webcam.snap(function(uri, canvas, context) {
        var data = context.getImageData(0, 0, 320, 240).data;

        // Sum up the red values
        var sum = 0;
        var max = 320 * 240 * 255;
        for (var i = 0; i < data.length; i += 4) {
          sum += data[i];
        }

        totalRed = sum / max;
        setTimeout(keepSummingThoseReds, 50);
      });
    }

    function readWebcam() {
      Webcam.set({
        width: 320,
        height: 240,
        dest_width: 320,
        dest_height: 240,
        image_format: 'jpeg',
        jpeg_quality: 90,
        force_flash: false
      });

      Webcam.attach("#webcam");

      Webcam.on('live', function() {
          setTimeout(keepSummingThoseReds, 1000);
      });
    }

    readWebcam();
    createImages();
  </script>
</html>
